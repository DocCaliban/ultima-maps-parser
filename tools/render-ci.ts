#!/usr/bin/env ts-node
import fs from 'fs';
import path from 'path';
import { PNG } from 'pngjs';

import { Towns, Castles, Dungeons, Arenas, Overworlds } from '../src/ultima-3/constants/ultima3.maps';
import { ImageFiles } from '../src/ultima-3/constants/ultima3.imgs';
import { decodeVGAPalette } from '../src/graphics/vga/vga.decoder';
import { buildCgaGraphicsArray, buildEgaGraphicsArray, buildVgaGraphicsArray } from '../src/ultima-3/decoders/u3.graphics.decoders';
import { renderMap } from './render.map';

const DATA_PATH = path.resolve('./assets/ultima-3');
const OUT_DIR = path.resolve('./out');

const allMaps = { ...Towns, ...Castles, ...Dungeons, ...Arenas, ...Overworlds, ...ImageFiles };

// CRC32 helper (small embedded implementation so we don't need extra deps)
const makeCrcTable = () => {
  const table = new Uint32Array(256);
  for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
      c = (c & 1) ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
    }
    table[n] = c >>> 0;
  }
  return table;
};
const CRC_TABLE = makeCrcTable();
const crc32 = (buf: Buffer | Uint8Array) => {
  let crc = 0xffffffff >>> 0;
  for (let i = 0; i < buf.length; i++) {
    const b = (buf as Uint8Array)[i] as number;
    const idx = (crc ^ b) & 0xff;
    const tableVal = CRC_TABLE[idx] as number;
    crc = (crc >>> 8) ^ tableVal;
  }
  return (crc ^ 0xffffffff) >>> 0;
};

// Known expected CRCs (mapFile -> mode -> crc32).
// Populate these after a successful render run so CI can compare without a reference image.
// Additionally we load `tools/expected-crc.json` (generated by `tools/generate-crc.ts`) and merge.
type CrcMap = Record<string, Record<string, number | null>>;
const EXPECTED_CRC: CrcMap = {
  // Standard map (fallback)
  'SOSARIA.ULT': { VGA: 0x59fcb0ad },
  'DEMO.ULT': { VGA: 0x288fa349 },
};

// Try to load generated JSON and merge into EXPECTED_CRC
try {
  const jsonPath = path.join(__dirname, 'expected-crc.json');
  if (fs.existsSync(jsonPath)) {
    const raw = fs.readFileSync(jsonPath, 'utf8');
    const parsed = JSON.parse(raw) as CrcMap;
    for (const k of Object.keys(parsed)) {
      EXPECTED_CRC[k] = EXPECTED_CRC[k] || {};
      const modes = parsed[k] || {};
      for (const m of Object.keys(modes)) {
        EXPECTED_CRC[k][m] = modes[m] as number | null;
      }
    }
    console.log(`Loaded expected CRCs from ${jsonPath}`);
  }
} catch (e) {
  console.warn('Could not load tools/expected-crc.json:', (e as any).message || e);
}

const findMapByFile = (fileName: string) => {
  for (const k of Object.keys(allMaps)) {
    const entry = (allMaps as any)[k];
    if (entry.file && entry.file.toLowerCase() === fileName.toLowerCase()) return entry;
  }
  return null;
};

const readPng = (p: string): Promise<PNG> =>
  new Promise((res, rej) => {
    fs.createReadStream(p)
      .pipe(new PNG())
      .on('parsed', function () {
        res(this as PNG);
      })
      .on('error', rej);
  });

const comparePngs = async (a: string, b: string) => {
  if (!fs.existsSync(a)) throw new Error(`Generated file not found: ${a}`);
  if (!fs.existsSync(b)) throw new Error(`Reference file not found: ${b}`);

  const pa = await readPng(a);
  const pb = await readPng(b);
  if (pa.width !== pb.width || pa.height !== pb.height) return { equal: false, reason: 'dimensions' };

  let diff = 0;
  for (let i = 0; i < pa.data.length; i++) {
    if (pa.data[i] !== pb.data[i]) diff++;
  }
  return { equal: diff === 0, pixelsDifferent: diff };
};

const main = async () => {
  const [, , mapFile = 'SOSARIA.ULT', mode = 'VGA', reference = ''] = process.argv;

  const map = findMapByFile(mapFile);
  if (!map) {
    console.error(`Map ${mapFile} not found in known resource lists.`);
    process.exit(2);
  }

  // Load palettes and tiles
  const palPath = path.join(DATA_PATH, 'U3VGA.PAL');
  let vgaPalette: any = undefined;
  try {
    if (fs.existsSync(palPath)) {
      const buf = fs.readFileSync(palPath);
      vgaPalette = decodeVGAPalette(buf as unknown as Uint8Array);
    }
  } catch (e) {
    console.warn('Could not load U3VGA.PAL, falling back to built-in palette.');
  }

  const rawCGA = fs.readFileSync(path.join(DATA_PATH, 'SHAPES.ULT'));
  const cgaTiles = buildCgaGraphicsArray(rawCGA, { width: 16, height: 16 }, require('../src/data/palettes').PALETTES.CGA_ALTERNATE);

  const rawEGA = fs.readFileSync(path.join(DATA_PATH, 'shapes.ega'));
  const egaTiles = buildEgaGraphicsArray(rawEGA, { width: 16, height: 16 }, require('../src/data/palettes').PALETTES.EGA_C64);

  const rawVGA = fs.readFileSync(path.join(DATA_PATH, 'SHAPES.VGA'));
  const vgaTiles = buildVgaGraphicsArray(rawVGA, { width: 16, height: 16 }, vgaPalette ?? require('../src/data/palettes').PALETTES.VGA_STANDARD);

  // Ensure out directory exists
  if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });

  // Render the map (renderMap writes files into ./out)
  await renderMap(map, mode.toUpperCase(), { cgaTiles, egaTiles, vgaTiles });

  // Determine generated filename
  const mapFileBase = map.file;
  const generated = path.join(OUT_DIR, `${mapFileBase}_${mode.toLowerCase()}.png`);

  // If no reference provided, compute and print CRC of generated image.
  if (!reference) {
    try {
      if (!fs.existsSync(generated)) throw new Error(`Generated file not found: ${generated}`);
      const buf = fs.readFileSync(generated);
      const crc = crc32(buf);
      const hex = `0x${crc.toString(16).padStart(8, '0')}`;
      console.log(`Rendered to ${generated}. CRC32=${hex}`);

      // If we have an expected CRC constant, compare now and set exit code accordingly
      const expectedForMap = EXPECTED_CRC[mapFileBase];
      if (expectedForMap && expectedForMap[mode.toUpperCase()]) {
        const expected = expectedForMap[mode.toUpperCase()] as number;
        if (expected === crc) {
          console.log('MATCH: generated CRC matches expected CRC constant.');
          process.exit(0);
        } else {
          console.log(`MISMATCH: expected 0x${expected.toString(16)}, got ${hex}`);
          process.exit(3);
        }
      }

      // Otherwise print CRC for manual capture and exit 0
      process.exit(0);
    } catch (err) {
      console.error('Error computing CRC:', err);
      process.exit(4);
    }
  }

  const refPath = path.resolve(reference);
  try {
    const result = await comparePngs(generated, refPath);
    if (result.equal) {
      console.log('MATCH: generated image matches reference exactly.');
      process.exit(0);
    } else {
      console.log('MISMATCH:', result);
      process.exit(3);
    }
  } catch (err) {
    console.error('Comparison failed:', err);
    process.exit(4);
  }
};

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
